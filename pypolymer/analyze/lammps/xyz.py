import numpy as np

def extract_mol(file_name,time_step='Last'):
    data = []
    time_line = []
    time_line_id = []
    atoms_list = []
    with open(file_name, 'r') as f:
        data = f.readlines()
        print('Lines of file:\n',len(data))
        print('Split label:\n', data[0].split('\n')[0])
        for idx in range(len(data)):
            if data[idx] == data[0]:
                time_line.append(data[idx+1].split('\n')[0])
                time_line_id.append(idx+1)
                atoms_list.append(int(data[idx+3].split('\n')[0]))
        f.close()
    print('Time step range:\n', time_line[0]+' to '+time_line[-1])
    print('Time step span:\n', int(time_line[1])- int(time_line[0]))
    print('Atoms in every time step:\n', atoms_list[0])
    try:
        time_step = int(input('输入转化xyz文件的时间节点：\n'))
        t_span = int(time_line[1])-int(time_line[0])
        start = int(int(time_line[0])/t_span)
        end = int(int(time_line[-1])/t_span)
        if time_step in [i for i in range(start, end+1)]:
            time_step = time_step*t_span
    except:
        raise ValueError('无效的时间节点！！！')
    print('----------------------------------------')
    print('选取的时间节点为：\n', str(time_step)+chr(953))
    print('正在提取......')
    print('----------------------------------------')
    start_id = 0+8
    atoms = atoms_list[0]
    try:
        if time_step.lower()=='last':
            start_id = time_line_id[-1]+8
            atoms = atoms_list[-1]
        elif time_step.lower()=='first':
            start_id = time_line_id[0]+8
            atoms = atoms_list[0]
    except:
        start_id = time_line_id[time_line.index(str(time_step))]+8
    mol_line_list = data[start_id:start_id+atoms]
    mol_mat = np.array([l.split() for l in mol_line_list], dtype=float)
    mol_mat = mol_mat[np.argsort(mol_mat[:,0], axis=0)]
    print('Dimension of matrix of whole mol system\n', mol_mat.shape)
    return mol_mat, atoms, time_step

def extract_chain(mol, atom_type=3):
    at = atom_type
    chain = mol[np.where(mol[:,1]==at)[0]]
    return chain[np.argsort(chain[:,0], axis=0)]
        
def split_chain(chain, mol_length):
    _c = [chain[i:i+mol_length, :] for i in range(0,chain.shape[0],mol_length)]
    return _c

def is_mol_out(mol, r_ange):
    #dist = [np.linalg.norm(l[2:5]) for l in mol]
    dist = [float(l[2]) for l in mol]
    if max(abs(np.array(dist)))>r_ange:
        return True
    else:
        return False

def gen_xyz_line(array):
    _l = [str(i) for i in array[2:5]]
    return ' '+str(int(array[1]))+' '+' '.join(_l) 
    
def gen_xyz_file(file_name='dump.lammpstrj', time_step='Last', atom_type=3.0, chain_length=10, R=1000):
    if isinstance(time_step, str):
        pass
    else:
        if time_step<1000:
            time_step = time_step*10000
    mol,atoms,time_step = extract_mol(file_name=file_name, time_step=time_step)
    chain = extract_chain(mol, atom_type)
    chain_l = split_chain(chain, chain_length)
    xyz_lines = []
    xyz_lines.append(str(atoms))
    xyz_lines.append(' Generated by pyLmp at t='+str(time_step)+chr(953))
    
    for sphere in mol:
        if sphere[1]!=atom_type:
            xyz_lines.append(gen_xyz_line(sphere))
    print('# of submol in total chain:\n', len(chain_l))
    print('Submol data shape:\n', chain_l[-1].shape)
    print('Atoms of cuted chain:\n', chain_l[-1].shape[0])
    for submol in chain_l:
        if is_mol_out(submol, R):
            continue
        else:
            for coord in submol:
                xyz_lines.append(gen_xyz_line(coord))
    out_file = str(time_step)+chr(953)+'.xyz'
    with open(out_file, 'w') as f:
        f.write('\n'.join(xyz_lines))
        f.close()
    return out_file
